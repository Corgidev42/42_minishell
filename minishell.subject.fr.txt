Voici la traduction du sujet du projet Minishell en franÃ§ais :

Minishell

Aussi beau quâ€™un shell

RÃ©sumÃ© :

Ce projet consiste Ã  crÃ©er un shell simple.

Oui, votre propre petit bash.
Vous apprendrez beaucoup sur les processus et les descripteurs de fichiers.

Version : 7.1

Chapitre I - Introduction

Lâ€™existence des shells est liÃ©e Ã  lâ€™existence mÃªme de lâ€™informatique.

Ã€ lâ€™Ã©poque, tous les dÃ©veloppeurs Ã©taient dâ€™accord pour dire que communiquer avec un ordinateur en utilisant des interrupteurs 1/0 alignÃ©s Ã©tait sÃ©rieusement agaÃ§ant.

Il Ã©tait donc logique dâ€™avoir lâ€™idÃ©e de crÃ©er un logiciel permettant de communiquer avec un ordinateur Ã  lâ€™aide de lignes de commande interactives dans un langage quelque peu proche du langage humain.

GrÃ¢ce Ã  Minishell, vous pourrez voyager dans le temps et revenir aux problÃ¨mes que rencontraient les gens avant lâ€™existence de Windows.

Chapitre II - Instructions gÃ©nÃ©rales
	â€¢	Votre projet doit Ãªtre Ã©crit en C.
	â€¢	Il doit Ãªtre conforme Ã  la Norminette. Les fichiers/fonctions bonus sont Ã©galement soumis Ã  cette norme et toute erreur entraÃ®nera une note de 0.
	â€¢	Vos fonctions ne doivent pas provoquer de plantages inattendus (segmentation fault, bus error, double free, etc.), sauf en cas de comportement indÃ©fini. Sinon, votre projet sera considÃ©rÃ© comme non fonctionnel et notÃ© 0.
	â€¢	Toute mÃ©moire allouÃ©e sur le tas (heap) doit Ãªtre correctement libÃ©rÃ©e. Aucune fuite de mÃ©moire ne sera tolÃ©rÃ©e.
	â€¢	Vous devez fournir un Makefile qui compile vos fichiers sources avec les options -Wall -Wextra -Werror, utilise cc et ne doit pas relinker.
	â€¢	Votre Makefile doit contenir au minimum les rÃ¨gles : $(NAME), all, clean, fclean et re.
	â€¢	Pour les bonus, une rÃ¨gle bonus doit Ãªtre ajoutÃ©e au Makefile et les fichiers doivent Ãªtre dans des fichiers distincts _bonus.{c/h}.
	â€¢	Si lâ€™utilisation de votre libft est autorisÃ©e, elle doit Ãªtre copiÃ©e dans un dossier libft avec son propre Makefile, et votre Makefile doit la compiler avant votre projet.
	â€¢	Il est recommandÃ© de crÃ©er des programmes de test, bien que non requis pour la soumission. Ils seront utiles pour tester votre projet et celui de vos camarades lors des soutenances.
	â€¢	Vous devez soumettre votre travail dans le dÃ©pÃ´t Git assignÃ©. Seul le travail prÃ©sent dans le dÃ©pÃ´t sera Ã©valuÃ©.
Si votre projet est Ã©valuÃ© par Deepthought, lâ€™Ã©valuation sâ€™arrÃªtera Ã  la premiÃ¨re erreur.

Chapitre III - Partie obligatoire

Informations gÃ©nÃ©rales :
	â€¢	Nom du programme : minishell
	â€¢	Fichiers Ã  rendre : Makefile, *.h, *.c
	â€¢	Makefile : Doit contenir les rÃ¨gles NAME, all, clean, fclean, re
	â€¢	Libft autorisÃ©e : Oui
	â€¢	Description : Ã‰crire un shell

FonctionnalitÃ©s attendues :

Votre shell doit :
	â€¢	Afficher un prompt lorsquâ€™il attend une commande.
	â€¢	GÃ©rer un historique des commandes.
	â€¢	Rechercher et exÃ©cuter les exÃ©cutables appropriÃ©s (via $PATH ou en utilisant un chemin absolu/relatif).
	â€¢	Ã‰viter lâ€™utilisation de variables globales, sauf pour indiquer un signal reÃ§u.
____________________________________________________________________________________
	â€¢	Ne pas interprÃ©ter les guillemets non fermÃ©s ou certains caractÃ¨res spÃ©ciaux non requis (ex. \, ;).
	â€¢	GÃ©rer les quotes :
	â€¢	' (simple quote) : empÃªche lâ€™interprÃ©tation des mÃ©tacaractÃ¨res.
	â€¢	" (double quote) : empÃªche lâ€™interprÃ©tation sauf pour $.
Les mÃ©tacaractÃ¨res sont des symboles qui ont une signification spÃ©ciale dans un shell. Ils ne sont pas interprÃ©tÃ©s comme de simples caractÃ¨res, mais modifient le comportement des commandes.

ğŸ”¹ Quâ€™est-ce quâ€™un mÃ©tacaractÃ¨re dans un shell ?

Les mÃ©tacaractÃ¨res sont des symboles qui ont une signification spÃ©ciale dans un shell. Ils ne sont pas interprÃ©tÃ©s comme de simples caractÃ¨res, mais modifient le comportement des commandes.

Exemples de mÃ©tacaractÃ¨res courants :
	â€¢	| (pipe) â†’ Envoie la sortie dâ€™une commande Ã  une autre.
	â€¢	> (redirection de sortie) â†’ Enregistre la sortie dans un fichier.
	â€¢	< (redirection dâ€™entrÃ©e) â†’ Utilise un fichier comme entrÃ©e.
	â€¢	&& et || â†’ ExÃ©cute conditionnellement des commandes.
	â€¢	; (point-virgule) â†’ SÃ©pare plusieurs commandes sur une seule ligne.
	â€¢	\ (backslash) â†’ Ã‰chappe un caractÃ¨re spÃ©cial.
	â€¢	$ â†’ Indique une variable dâ€™environnement (ex: $HOME).
	â€¢	* â†’ Wildcard (correspond Ã  plusieurs fichiers).

Dans Minishell, il est crucial de gÃ©rer correctement ces caractÃ¨res, notamment avec les quotes (' et ").

ğŸ”¹ Pourquoi ne pas interprÃ©ter les guillemets non fermÃ©s ?

Un shell comme bash attend que toutes les quotes ouvertes soient fermÃ©es avant dâ€™exÃ©cuter une commande.

Exemple de problÃ¨me :

$ echo 'Hello World
>  # Le shell attend toujours la fermeture du '

Le prompt > signifie que le shell attend encore la fermeture de la quote.

ğŸ”´ Dans Minishell, si une quote est ouverte sans Ãªtre fermÃ©e, il ne faut pas exÃ©cuter la commande. Il faut gÃ©rer ce cas pour Ã©viter des comportements imprÃ©visibles.

ğŸ”¹ DiffÃ©rence entre les guillemets simples ' et doubles "

Les quotes sont utilisÃ©es pour gÃ©rer comment les mÃ©tacaractÃ¨res doivent Ãªtre interprÃ©tÃ©s.

1ï¸âƒ£ Les guillemets simples ' : DÃ©sactivation totale des mÃ©tacaractÃ¨res

Tout ce qui est entre guillemets simples est interprÃ©tÃ© tel quel, sans exception.

âœ… Exemple avec une variable :

$ echo '$USER'
$USER  # La variable n'est PAS Ã©valuÃ©e

âœ… Exemple avec un mÃ©tacaractÃ¨re :

$ echo 'Hello | World'
Hello | World  # Le pipe `|` n'est pas interprÃ©tÃ©

ğŸ›‘ Attention : Impossible dâ€™inclure un ' Ã  lâ€™intÃ©rieur dâ€™une chaÃ®ne dÃ©jÃ  entourÃ©e de ' :

$ echo 'Hello 'world''
bash: unexpected EOF while looking for matching `'`

2ï¸âƒ£ Les guillemets doubles " : DÃ©sactivation partielle

Les guillemets doubles empÃªchent lâ€™interprÃ©tation de presque tous les mÃ©tacaractÃ¨res, sauf $.

âœ… Exemple avec une variable :

$ echo "Bonjour $USER"
Bonjour vincent  # La variable est Ã©valuÃ©e

âœ… Exemple avec un mÃ©tacaractÃ¨re :

$ echo "Hello | World"
Hello | World  # Le pipe est traitÃ© comme du texte

ğŸ›‘ Cas spÃ©cial : " permet lâ€™interprÃ©tation des variables ($VAR) mais pas des autres mÃ©tacaractÃ¨res.

ğŸ”´ Exemple avec backslash \ :

$ echo "Hello \"World\""
Hello "World"  # Le backslash fonctionne pour Ã©chapper les doubles quotes

ğŸ”¹ En rÃ©sumÃ© :

Type de Quote	EmpÃªche tous les mÃ©tacaractÃ¨res ?	Les variables $VAR sont interprÃ©tÃ©es ?
' (simple quote)	âœ… OUI	âŒ NON
" (double quote)	âŒ NON (seul $ fonctionne)	âœ… OUI

ğŸ”¹ Application dans Minishell

âœ… Ce quâ€™il faut faire :
	1.	Ne pas interprÃ©ter les quotes non fermÃ©es (echo "test â†’ attente de fermeture).
	2.	Traiter correctement ' pour dÃ©sactiver tout (echo 'Hello | $USER' â†’ affiche exactement Hello | $USER).
	3.	Traiter correctement " pour dÃ©sactiver tout sauf $ (echo "Hello $USER" â†’ affiche Hello vincent).

____________________________________________________________________________________
	â€¢	ImplÃ©menter les redirections :
	â€¢	< : redirige lâ€™entrÃ©e.
	â€¢	> : redirige la sortie.
	â€¢	<< : lit lâ€™entrÃ©e jusquâ€™Ã  un dÃ©limiteur.
	â€¢	>> : redirige la sortie en mode append.

ğŸ”¹ Fonctionnement des redirections dans un shell

Les redirections permettent de modifier les flux dâ€™entrÃ©e et de sortie dâ€™une commande. Elles utilisent les descripteurs de fichiers standard :
	â€¢	0 â†’ STDIN (entrÃ©e standard)
	â€¢	1 â†’ STDOUT (sortie standard)
	â€¢	2 â†’ STDERR (sortie dâ€™erreur)

Dans Minishell, tu dois implÃ©menter 4 types de redirections.

1ï¸âƒ£ < : Redirection de lâ€™entrÃ©e standard

ğŸ“Œ Utilisation :

command < fichier

ğŸ”¹ Cela remplace lâ€™entrÃ©e standard (stdin) par le contenu de fichier.

âœ… Exemple :

cat < input.txt

Au lieu de lire depuis le clavier, cat lira directement le contenu de input.txt.

ğŸ”¹ Comment Ã§a marche en C ?
	1.	Ouvrir le fichier en lecture (O_RDONLY).
	2.	Remplacer STDIN avec le fichier en utilisant dup2().
	3.	ExÃ©cuter la commande.

ğŸ“Œ Code C pour < :

int fd = open("input.txt", O_RDONLY);
dup2(fd, 0);  // Redirige STDIN vers fd
close(fd);
execlp("cat", "cat", NULL);  // ExÃ©cute cat

2ï¸âƒ£ > : Redirection de la sortie standard

ğŸ“Œ Utilisation :

command > fichier

ğŸ”¹ Cela remplace la sortie standard (stdout) et Ã©crit le rÃ©sultat dans fichier.

âœ… Exemple :

echo "Hello" > output.txt

output.txt contiendra "Hello" au lieu de lâ€™afficher dans le terminal.

ğŸ”¹ Comment Ã§a marche en C ?
	1.	Ouvrir le fichier en Ã©criture (O_WRONLY | O_CREAT | O_TRUNC).
	2.	Remplacer STDOUT avec ce fichier via dup2().
	3.	ExÃ©cuter la commande.

ğŸ“Œ Code C pour > :

int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
dup2(fd, 1);  // Redirige STDOUT vers fd
close(fd);
execlp("echo", "echo", "Hello", NULL);  // ExÃ©cute echo

3ï¸âƒ£ >> : Redirection en mode append

ğŸ“Œ Utilisation :

command >> fichier

ğŸ”¹ Semblable Ã  > mais ajoute Ã  la fin du fichier au lieu de lâ€™Ã©craser.

âœ… Exemple :

echo "Hello" >> output.txt

Si output.txt contient dÃ©jÃ  "Bonjour", aprÃ¨s la commande il aura :

Bonjour
Hello

ğŸ”¹ Comment Ã§a marche en C ?
	1.	Ouvrir le fichier en mode append (O_WRONLY | O_CREAT | O_APPEND).
	2.	Remplacer STDOUT avec ce fichier via dup2().
	3.	ExÃ©cuter la commande.

ğŸ“Œ Code C pour >> :

int fd = open("output.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
dup2(fd, 1);  // Redirige STDOUT vers fd
close(fd);
execlp("echo", "echo", "Hello", NULL);  // ExÃ©cute echo

4ï¸âƒ£ << : Here-document (entrÃ©e jusquâ€™Ã  un dÃ©limiteur)

ğŸ“Œ Utilisation :

command << DELIMITEUR

ğŸ”¹ Cela lit lâ€™entrÃ©e jusquâ€™Ã  rencontrer le mot DELIMITEUR.

âœ… Exemple :

cat << EOF
Hello
World
EOF

Cela va envoyer â€œHello\nWorld\nâ€ Ã  cat.

ğŸ”¹ Comment Ã§a marche en C ?
	1.	Lire ligne par ligne depuis lâ€™entrÃ©e (stdin).
	2.	ArrÃªter dÃ¨s que le dÃ©limiteur est trouvÃ©.
	3.	Fournir ces lignes comme entrÃ©e Ã  la commande.

ğŸ“Œ Code C pour << (simplifiÃ©) :

char *line;
int pipefd[2];

pipe(pipefd);  // CrÃ©ation du pipe
while ((line = readline("> "))) {  // Lire l'entrÃ©e utilisateur
    if (strcmp(line, "EOF") == 0) break;  // VÃ©rifie si c'est le dÃ©limiteur
    write(pipefd[1], line, strlen(line));  // Ã‰crit dans le pipe
    write(pipefd[1], "\n", 1);
}
close(pipefd[1]);  // Fermer l'Ã©criture
dup2(pipefd[0], 0);  // Rediriger STDIN vers le pipe
execlp("cat", "cat", NULL);


____________________________________________________________________________________

	â€¢	ImplÃ©menter les pipes (|) : la sortie dâ€™une commande devient lâ€™entrÃ©e de la suivante.
	â€¢	GÃ©rer les variables dâ€™environnement ($VAR).
	â€¢	GÃ©rer ?, qui doit contenir le code de sortie du dernier pipeline exÃ©cutÃ©.
	â€¢	GÃ©rer les signaux (ctrl-C, ctrl-D, ctrl-\) :
	â€¢	ctrl-C : affiche un nouveau prompt sur une nouvelle ligne.
	â€¢	ctrl-D : quitte le shell.
	â€¢	ctrl-\ : ne fait rien en mode interactif.
	â€¢	ImplÃ©menter les builtins suivants :
	â€¢	echo avec option -n
	â€¢	cd (avec un chemin relatif ou absolu)
	â€¢	pwd (sans option)
	â€¢	export (sans option)
	â€¢	unset (sans option)
	â€¢	env (sans option/argument)
	â€¢	exit (sans option)

âš ï¸ Attention : La fonction readline() peut provoquer des fuites de mÃ©moire. Vous nâ€™avez pas Ã  les corriger, mais votre propre code ne doit pas en avoir.

ğŸ’¡ Conseil : Si un comportement nâ€™est pas clairement dÃ©fini, utilisez bash comme rÃ©fÃ©rence.

Chapitre IV - Partie Bonus

Si vous souhaitez aller plus loin, votre programme peut aussi :
	â€¢	ImplÃ©menter && et || avec gestion des prioritÃ©s via des parenthÃ¨ses.
	â€¢	GÃ©rer les wildcards (*) pour le rÃ©pertoire courant.

âš ï¸ Important : La partie bonus ne sera Ã©valuÃ©e que si la partie obligatoire est parfaite.
â€œParfaiteâ€ signifie que toutes les fonctionnalitÃ©s demandÃ©es fonctionnent sans erreurs.

Chapitre V - Soumission et Ã©valuation par les pairs
	â€¢	Soumettez votre projet dans votre dÃ©pÃ´t Git assignÃ©.
	â€¢	Seul le contenu de ce dÃ©pÃ´t sera Ã©valuÃ© lors de la soutenance.
	â€¢	VÃ©rifiez attentivement les noms de fichiers et leur conformitÃ© avec le sujet avant de rendre votre projet.

Ceci est la traduction complÃ¨te du sujet Minishell en franÃ§ais. ğŸ˜Š Si tu veux des prÃ©cisions sur une partie spÃ©cifique ou des conseils pour avancer dans le projet, nâ€™hÃ©site pas ! ğŸš€
