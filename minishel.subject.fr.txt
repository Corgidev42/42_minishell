Voici la traduction du sujet du projet Minishell en franÃ§ais :

Minishell

Aussi beau quâ€™un shell

RÃ©sumÃ© :

Ce projet consiste Ã  crÃ©er un shell simple.

Oui, votre propre petit bash.
Vous apprendrez beaucoup sur les processus et les descripteurs de fichiers.

Version : 7.1

Chapitre I - Introduction

Lâ€™existence des shells est liÃ©e Ã  lâ€™existence mÃªme de lâ€™informatique.

Ã€ lâ€™Ã©poque, tous les dÃ©veloppeurs Ã©taient dâ€™accord pour dire que communiquer avec un ordinateur en utilisant des interrupteurs 1/0 alignÃ©s Ã©tait sÃ©rieusement agaÃ§ant.

Il Ã©tait donc logique dâ€™avoir lâ€™idÃ©e de crÃ©er un logiciel permettant de communiquer avec un ordinateur Ã  lâ€™aide de lignes de commande interactives dans un langage quelque peu proche du langage humain.

GrÃ¢ce Ã  Minishell, vous pourrez voyager dans le temps et revenir aux problÃ¨mes que rencontraient les gens avant lâ€™existence de Windows.

Chapitre II - Instructions gÃ©nÃ©rales
	â€¢	Votre projet doit Ãªtre Ã©crit en C.
	â€¢	Il doit Ãªtre conforme Ã  la Norminette. Les fichiers/fonctions bonus sont Ã©galement soumis Ã  cette norme et toute erreur entraÃ®nera une note de 0.
	â€¢	Vos fonctions ne doivent pas provoquer de plantages inattendus (segmentation fault, bus error, double free, etc.), sauf en cas de comportement indÃ©fini. Sinon, votre projet sera considÃ©rÃ© comme non fonctionnel et notÃ© 0.
	â€¢	Toute mÃ©moire allouÃ©e sur le tas (heap) doit Ãªtre correctement libÃ©rÃ©e. Aucune fuite de mÃ©moire ne sera tolÃ©rÃ©e.
	â€¢	Vous devez fournir un Makefile qui compile vos fichiers sources avec les options -Wall -Wextra -Werror, utilise cc et ne doit pas relinker.
	â€¢	Votre Makefile doit contenir au minimum les rÃ¨gles : $(NAME), all, clean, fclean et re.
	â€¢	Pour les bonus, une rÃ¨gle bonus doit Ãªtre ajoutÃ©e au Makefile et les fichiers doivent Ãªtre dans des fichiers distincts _bonus.{c/h}.
	â€¢	Si lâ€™utilisation de votre libft est autorisÃ©e, elle doit Ãªtre copiÃ©e dans un dossier libft avec son propre Makefile, et votre Makefile doit la compiler avant votre projet.
	â€¢	Il est recommandÃ© de crÃ©er des programmes de test, bien que non requis pour la soumission. Ils seront utiles pour tester votre projet et celui de vos camarades lors des soutenances.
	â€¢	Vous devez soumettre votre travail dans le dÃ©pÃ´t Git assignÃ©. Seul le travail prÃ©sent dans le dÃ©pÃ´t sera Ã©valuÃ©.
Si votre projet est Ã©valuÃ© par Deepthought, lâ€™Ã©valuation sâ€™arrÃªtera Ã  la premiÃ¨re erreur.

Chapitre III - Partie obligatoire

Informations gÃ©nÃ©rales :
	â€¢	Nom du programme : minishell
	â€¢	Fichiers Ã  rendre : Makefile, *.h, *.c
	â€¢	Makefile : Doit contenir les rÃ¨gles NAME, all, clean, fclean, re
	â€¢	Libft autorisÃ©e : Oui
	â€¢	Description : Ã‰crire un shell

FonctionnalitÃ©s attendues :

Votre shell doit :
	â€¢	Afficher un prompt lorsquâ€™il attend une commande.
	â€¢	GÃ©rer un historique des commandes.
	â€¢	Rechercher et exÃ©cuter les exÃ©cutables appropriÃ©s (via $PATH ou en utilisant un chemin absolu/relatif).
	â€¢	Ã‰viter lâ€™utilisation de variables globales, sauf pour indiquer un signal reÃ§u.
	â€¢	Ne pas interprÃ©ter les guillemets non fermÃ©s ou certains caractÃ¨res spÃ©ciaux non requis (ex. \, ;).
	â€¢	GÃ©rer les quotes :
	â€¢	' (simple quote) : empÃªche lâ€™interprÃ©tation des mÃ©tacaractÃ¨res.
	â€¢	" (double quote) : empÃªche lâ€™interprÃ©tation sauf pour $.
	â€¢	ImplÃ©menter les redirections :
	â€¢	< : redirige lâ€™entrÃ©e.
	â€¢	> : redirige la sortie.
	â€¢	<< : lit lâ€™entrÃ©e jusquâ€™Ã  un dÃ©limiteur.
	â€¢	>> : redirige la sortie en mode append.
	â€¢	ImplÃ©menter les pipes (|) : la sortie dâ€™une commande devient lâ€™entrÃ©e de la suivante.
	â€¢	GÃ©rer les variables dâ€™environnement ($VAR).
	â€¢	GÃ©rer ?, qui doit contenir le code de sortie du dernier pipeline exÃ©cutÃ©.
	â€¢	GÃ©rer les signaux (ctrl-C, ctrl-D, ctrl-\) :
	â€¢	ctrl-C : affiche un nouveau prompt sur une nouvelle ligne.
	â€¢	ctrl-D : quitte le shell.
	â€¢	ctrl-\ : ne fait rien en mode interactif.
	â€¢	ImplÃ©menter les builtins suivants :
	â€¢	echo avec option -n
	â€¢	cd (avec un chemin relatif ou absolu)
	â€¢	pwd (sans option)
	â€¢	export (sans option)
	â€¢	unset (sans option)
	â€¢	env (sans option/argument)
	â€¢	exit (sans option)

âš ï¸ Attention : La fonction readline() peut provoquer des fuites de mÃ©moire. Vous nâ€™avez pas Ã  les corriger, mais votre propre code ne doit pas en avoir.

ğŸ’¡ Conseil : Si un comportement nâ€™est pas clairement dÃ©fini, utilisez bash comme rÃ©fÃ©rence.

Chapitre IV - Partie Bonus

Si vous souhaitez aller plus loin, votre programme peut aussi :
	â€¢	ImplÃ©menter && et || avec gestion des prioritÃ©s via des parenthÃ¨ses.
	â€¢	GÃ©rer les wildcards (*) pour le rÃ©pertoire courant.

âš ï¸ Important : La partie bonus ne sera Ã©valuÃ©e que si la partie obligatoire est parfaite.
â€œParfaiteâ€ signifie que toutes les fonctionnalitÃ©s demandÃ©es fonctionnent sans erreurs.

Chapitre V - Soumission et Ã©valuation par les pairs
	â€¢	Soumettez votre projet dans votre dÃ©pÃ´t Git assignÃ©.
	â€¢	Seul le contenu de ce dÃ©pÃ´t sera Ã©valuÃ© lors de la soutenance.
	â€¢	VÃ©rifiez attentivement les noms de fichiers et leur conformitÃ© avec le sujet avant de rendre votre projet.

Ceci est la traduction complÃ¨te du sujet Minishell en franÃ§ais. ğŸ˜Š Si tu veux des prÃ©cisions sur une partie spÃ©cifique ou des conseils pour avancer dans le projet, nâ€™hÃ©site pas ! ğŸš€
