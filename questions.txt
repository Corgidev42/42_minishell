Dans Minishell, lâ€™utilisation des variables globales est fortement dÃ©conseillÃ©e, sauf pour indiquer quâ€™un signal a Ã©tÃ© reÃ§u. Voici pourquoi :

1ï¸âƒ£ Pourquoi Ã©viter les variables globales ?

Les variables globales posent plusieurs problÃ¨mes :
	â€¢	SÃ©curitÃ© : Elles peuvent Ãªtre modifiÃ©es nâ€™importe oÃ¹ dans le code, ce qui peut rendre le dÃ©bogage difficile.
	â€¢	LisibilitÃ© & modularitÃ© : Elles rendent le code moins clair et plus difficile Ã  maintenir.
	â€¢	ProblÃ¨mes de concurrence : Dans un environnement multithreadÃ© (mÃªme si ce nâ€™est pas le cas ici), elles peuvent entraÃ®ner des conflits.
	â€¢	Bash nâ€™utilise pas de globales : Bash et les autres shells fonctionnent sans variables globales pour les Ã©tats internes, donc il est logique de suivre cette approche.

Cependant, un signal reÃ§u doit Ãªtre enregistrÃ© quelque part, et la seule exception autorisÃ©e pour une variable globale est son utilisation pour stocker ce signal.

2ï¸âƒ£ Pourquoi a-t-on besoin de gÃ©rer les signaux ?

Les signaux sont utilisÃ©s pour interagir avec le shell et gÃ©rer des situations importantes comme lâ€™interruption dâ€™une commande. Voici les cas principaux :

ğŸ“Œ Interruption de lâ€™exÃ©cution
	â€¢	CTRL + C (SIGINT) :
	â€¢	Permet Ã  lâ€™utilisateur dâ€™interrompre une commande en cours (comme cat ou sleep).
	â€¢	Le shell doit afficher un nouveau prompt au lieu de quitter complÃ¨tement.
	â€¢	CTRL + D (EOF) :
	â€¢	Sert Ã  fermer le shell proprement si lâ€™utilisateur est en mode interactif.
	â€¢	CTRL + \ (SIGQUIT) :
	â€¢	Doit Ãªtre ignorÃ© dans bash, donc votre Minishell doit aussi le gÃ©rer.

ğŸ“Œ Propagation des signaux aux processus fils
	â€¢	Lorsque Minishell exÃ©cute une commande (ex: sleep 10), elle est lancÃ©e dans un processus fils.
	â€¢	Si lâ€™utilisateur fait CTRL + C, le signal doit Ãªtre envoyÃ© au bon processus, mais le shell ne doit pas Ãªtre interrompu.

ğŸ“Œ RÃ©cupÃ©rer le code de sortie des processus
	â€¢	$? doit contenir le code de retour du dernier processus exÃ©cutÃ©.
	â€¢	Si un processus est interrompu par un signal, son code de retour doit reflÃ©ter cela.

3ï¸âƒ£ Pourquoi une variable globale pour les signaux est-elle autorisÃ©e ?

Un gestionnaire de signal (signal(), sigaction()) ne peut pas exÃ©cuter de code complexe directement, car il interrompt lâ€™exÃ©cution normale du programme.

ğŸ’¡ Solution :
	â€¢	Utiliser une seule variable globale pour enregistrer le dernier signal reÃ§u.
	â€¢	Ensuite, dans la boucle principale du shell, vÃ©rifier cette variable et agir en consÃ©quence.

Exemple :

#include <signal.h>
#include <stdio.h>
#include <unistd.h>

volatile sig_atomic_t g_signal_received = 0;

void signal_handler(int sig) {
    g_signal_received = sig;  // Stocke le signal reÃ§u
}

int main() {
    signal(SIGINT, signal_handler);  // Capture CTRL + C

    while (1) {
        if (g_signal_received == SIGINT) {
            printf("\nSignal SIGINT reÃ§u ! Affichage d'un nouveau prompt.\n");
            g_signal_received = 0; // RÃ©initialisation
        }
        printf("minishell$ ");
        fflush(stdout);
        sleep(1);
    }

    return 0;
}

Dans cet exemple :
	â€¢	CTRL + C ne tue pas le shell mais dÃ©clenche une action contrÃ´lÃ©e (afficher un nouveau prompt).
	â€¢	g_signal_received est la seule variable globale autorisÃ©e.

ğŸ”¹ En rÃ©sumÃ© :

âœ… Ã‰viter les variables globales rend le code plus propre et plus modulaire.
âœ… Les signaux sont essentiels pour interagir avec lâ€™utilisateur (CTRL+C, CTRL+D).
âœ… Une seule variable globale est autorisÃ©e pour stocker le signal reÃ§u et lâ€™utiliser proprement dans la boucle principale.

Si tu veux plus de dÃ©tails sur la gestion des signaux dans Minishell, dis-moi ! ğŸš€

______________________________________________________________________________________________________________________________
ğŸ”¹ Quâ€™est-ce quâ€™un mÃ©tacaractÃ¨re dans un shell ?

Les mÃ©tacaractÃ¨res sont des symboles qui ont une signification spÃ©ciale dans un shell. Ils ne sont pas interprÃ©tÃ©s comme de simples caractÃ¨res, mais modifient le comportement des commandes.

Exemples de mÃ©tacaractÃ¨res courants :
	â€¢	| (pipe) â†’ Envoie la sortie dâ€™une commande Ã  une autre.
	â€¢	> (redirection de sortie) â†’ Enregistre la sortie dans un fichier.
	â€¢	< (redirection dâ€™entrÃ©e) â†’ Utilise un fichier comme entrÃ©e.
	â€¢	&& et || â†’ ExÃ©cute conditionnellement des commandes.
	â€¢	; (point-virgule) â†’ SÃ©pare plusieurs commandes sur une seule ligne.
	â€¢	\ (backslash) â†’ Ã‰chappe un caractÃ¨re spÃ©cial.
	â€¢	$ â†’ Indique une variable dâ€™environnement (ex: $HOME).
	â€¢	* â†’ Wildcard (correspond Ã  plusieurs fichiers).

Dans Minishell, il est crucial de gÃ©rer correctement ces caractÃ¨res, notamment avec les quotes (' et ").

ğŸ”¹ Pourquoi ne pas interprÃ©ter les guillemets non fermÃ©s ?

Un shell comme bash attend que toutes les quotes ouvertes soient fermÃ©es avant dâ€™exÃ©cuter une commande.

Exemple de problÃ¨me :

$ echo 'Hello World
>  # Le shell attend toujours la fermeture du '

Le prompt > signifie que le shell attend encore la fermeture de la quote.

ğŸ”´ Dans Minishell, si une quote est ouverte sans Ãªtre fermÃ©e, il ne faut pas exÃ©cuter la commande. Il faut gÃ©rer ce cas pour Ã©viter des comportements imprÃ©visibles.

ğŸ”¹ DiffÃ©rence entre les guillemets simples ' et doubles "

Les quotes sont utilisÃ©es pour gÃ©rer comment les mÃ©tacaractÃ¨res doivent Ãªtre interprÃ©tÃ©s.

1ï¸âƒ£ Les guillemets simples ' : DÃ©sactivation totale des mÃ©tacaractÃ¨res

Tout ce qui est entre guillemets simples est interprÃ©tÃ© tel quel, sans exception.

âœ… Exemple avec une variable :

$ echo '$USER'
$USER  # La variable n'est PAS Ã©valuÃ©e

âœ… Exemple avec un mÃ©tacaractÃ¨re :

$ echo 'Hello | World'
Hello | World  # Le pipe `|` n'est pas interprÃ©tÃ©

ğŸ›‘ Attention : Impossible dâ€™inclure un ' Ã  lâ€™intÃ©rieur dâ€™une chaÃ®ne dÃ©jÃ  entourÃ©e de ' :

$ echo 'Hello 'world''
bash: unexpected EOF while looking for matching `'`

2ï¸âƒ£ Les guillemets doubles " : DÃ©sactivation partielle

Les guillemets doubles empÃªchent lâ€™interprÃ©tation de presque tous les mÃ©tacaractÃ¨res, sauf $.

âœ… Exemple avec une variable :

$ echo "Bonjour $USER"
Bonjour vincent  # La variable est Ã©valuÃ©e

âœ… Exemple avec un mÃ©tacaractÃ¨re :

$ echo "Hello | World"
Hello | World  # Le pipe est traitÃ© comme du texte

ğŸ›‘ Cas spÃ©cial : " permet lâ€™interprÃ©tation des variables ($VAR) mais pas des autres mÃ©tacaractÃ¨res.

ğŸ”´ Exemple avec backslash \ :

$ echo "Hello \"World\""
Hello "World"  # Le backslash fonctionne pour Ã©chapper les doubles quotes

ğŸ”¹ En rÃ©sumÃ© :

Type de Quote	EmpÃªche tous les mÃ©tacaractÃ¨res ?	Les variables $VAR sont interprÃ©tÃ©es ?
' (simple quote)	âœ… OUI	âŒ NON
" (double quote)	âŒ NON (seul $ fonctionne)	âœ… OUI

ğŸ”¹ Application dans Minishell

âœ… Ce quâ€™il faut faire :
	1.	Ne pas interprÃ©ter les quotes non fermÃ©es (echo "test â†’ attente de fermeture).
	2.	Traiter correctement ' pour dÃ©sactiver tout (echo 'Hello | $USER' â†’ affiche exactement Hello | $USER).
	3.	Traiter correctement " pour dÃ©sactiver tout sauf $ (echo "Hello $USER" â†’ affiche Hello vincent).

âŒ Ce quâ€™il ne faut pas faire :

ğŸš« MÃ©langer les quotes mal fermÃ©es (echo 'Hello "World doit afficher une erreur).
ğŸš« InterprÃ©ter $ Ã  lâ€™intÃ©rieur de ' (echo '$USER' ne doit pas afficher la valeur de $USER).
ğŸš« Ignorer le comportement spÃ©cial des mÃ©tacaractÃ¨res (echo "Hello | World" ne doit PAS exÃ©cuter un pipe).

Si tu veux voir comment coder Ã§a dans Minishell, je peux tâ€™expliquer comment parser les quotes ! ğŸš€
